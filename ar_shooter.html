<!DOCTYPE html>
<head>
    <meta name='viewport' content='width=device-width, initial-scale=1' />
    <link href='assets/index.html'>
    <title>Hayden Lovato - Rhetorical Analysis: AR Shooter Game</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
            crossorigin="anonymous"></script>
    <link rel="stylesheet" href="style.css">
</head>

<nav>
            <a href="index.html" class="button">Home</a>
</nav>

<hr />
  
<body>
    <header><h1>Rhetorical Analysis: Individual Game</h1></header>
<div class="container">
            <div class="row g-0 text-center">
		     <section>
    <h2>Intro</h2>
    <p>
	Going into this project, I really didn’t think I would be able to interact and work coherently with others in a course I never had experience with. But even after the individual assignment, I was very surprised by my experience in working with them when it came to fixing bugs and issues with the unity animations and interaction. After the first two weeks of working together, I got much more involved and took advantage of having others to cover for certain parts. Adding a lot of personal additions to the game added much more personality to the game than it would’ve had without it. It really just came down to how many reasonable additions can I make to this game without disrupting the workflow of my teammates. I eventually started to research music references of a similar genre, medieval. But since the weaponry was mainly modern, I also had to incorporate sound effects to insinuate the weapons in use. After a while I found Castle Crashers and the Star Wars soundtrack were good reference materials to base my music development on. This eventually led to my intro animation design being based off castle crashers and my main gameplay music design being based off a march from John Williams. 
    </p>

    <h2>Art Design</h2>
    <p>
I stumbled upon Momodora: Reverie Under The Moonlight when I started exploring pixel art styles. The art style was very charming and gave a lot of personality to its characters. I was very new to using Unity and Adobe Photoshop, so drawing the art was the longest part of my experience. My art turned out to be more overly detailed than I had planned, negating my goal of simplicity. My art started to be inconsistent, with too much detail in the terrain and walls and a lack of detail in the enemy sprites. The backgrounds were added last and were rushed, so they stick out a bit too much due to their lack of quality.
The most frustrating part of the art design was the animations. I had no prior experience in animation and used sprite sheets to formulate my animations. But, due to my over-detailing in my character, I struggled to animate their body parts. In many pixel games, the average sprite is made in 16x16, and the simplicity in detail allows for the actions of the sprite to be more vague. Allowing for effects to telegraph the character's movements rather than the movements themselves. This way of animating has been used for a while, and rather than being considered as cutting corners, this way of using smears, squash and stretch, anticipation, exaggeration, and secondary action shines personality in a character and art style. 
For example, the game Celeste uses squash and stretch to emphasize the character's momentum transfer to its surroundings, such as landing on the floor or a wall. Minor wind effects are then added to give personality to its movement and add charm. Running is simplified between a few frames, ignoring the effort of moving every joint in the leg. Having too much detail in a game can be effective, but it can stick out when it's not given effective animation. Using a simplistic art style isn’t bad and can be more effective. An example of this phenomenon would be the Pokemon series. Pokemon had a lot of charm with its pixel art, and thorough animations weren’t needed due to its environment and gameplay carrying the weight. But when they advanced to a 3D art style, the Pokemon animations didn’t match their 3D sprites and their surroundings, making them stick out when in use, lacking in personality and appeal. 
</p>
			     
<h2>Story Design</h2>
<p>
For my story direction, I went for a Soulsborne approach. The main character (player) is a nameless knight who took an oath 1000 years ago to a now-fallen Monarchy to fight for humanity no matter the challenge. But the character doesn’t hold any conviction in fighting for humanity for eternity. Even so, he is bound to keep reviving even against his wishes, both as a sworn duty and as a punishment for his blind naivety. Even after losing his family, he lives a solitary life, that is, until crystal-like meteors fall from the sky, emitting a toxic fog around them. One of those meteors crash down onto the character's house, and with that being the last memorabilia of his family, he turns to it and kills himself. With humanity in turmoil once more, he is forced to rise once again as a tool for humanity's salvation. I gained a lot of this character background from some Destiny inspiration in lore entries. For example, many Guardians in lore would kill themselves over and over again, either as an act of insanity or lack of purpose. Needing to serve as soldiers for a solitary deity and as a weapon for humanity’s survival.
For world development, the game is set in a fantasy medieval setting where kingdoms rule the land and faith to god is a strong practice. But when the meteors hit, the toxic fog starts consuming humans and animals alike to form into undeveloped sludges, taking upon the intelligence of its victims. The tendril-like substances are called Croth and are formed when the substance lacks any human intelligence, grasping at any other form of intelligence in an effort to evolve. The conscious sludges called Goombles shoot hardened crystals as a form of attack. They can be seen with an assortment of bones and parts floating in their body, forming itself into a single being from its various victims. The footsoldiers are named Cassorwarys, and it formulates itself as an imitation of higher intelligence. It brandishes a crystal sword from its body and limps as it walks due to its lack of experience. Finally, the boss, Archbishop Adrien, is an amalgamation of the fanatical Archbishop of the church and his dedicated followers. When he experienced the invasion, he felt it was a message from God to allow the Earth to evolve and allow humanity to flourish. The beast that is born is inspired by the mythical beast, the Wendigo, and the lower half is based on a Pope’s garment.
Finally, the hierarchy of the alien species is based on their crystalline structure. As they form into sludges after absorbing enough mass, such as Goombles, they slowly evolve once they gain enough silicon within their masses. Allowing them to emerge as Cassowarys, their structure begins to solidify slowly. As shown in the Archbishop phase change, the dark formation on its body darkens, and it sheds its skull for a quartz head. The species absorbs surrounding oxygen and silicon to form crystalline nonorganics that share the same chemical compound as amethysts (SiO2). Due to this phenomenon, their invasion led to the Moon crystalizing into a tetrahedron structure due to the mass amount of silicon and oxygen present in its crust. This can be seen during the boss battle.
</p>
	
<h2>Music Design</h2>
<p>
When it came to music direction, I gained a lot of inspiration from the music producers Micheal Salvatori of the Destiny Series soundtrack and DM Dokuro of the Terraria Calamity Mod soundtrack. While I only made two songs dedicated to this game, that being the title screen music and the boss music, both had great effort towards them. I especially enjoyed making the boss music. At the start of the piece, it enters with a chord progression from the organ along with a chime accompaniment, symbolizing a consecrated setting since the boss room is a church. The pace picks up along with plucked strings to build tension and add to an eerie motion. This continues to build, adding a laying harpsichord to the string melody and finally relaxing and then building the tension back into the main melody. The main melody is inspired by DM Dokuro’s Return to Slime part, symbolizing chaos, using the lower-voiced instruments for the melody line while using the choir for the upbeats. This use of the lower-voiced instruments heavily details the stature of the boss, while the organ and choir call & response, along with the drumset, gives momentum. The next part prioritizes the fact the boss is an amalgamation of hundreds of corpses, giving a disgusting tone to the melody progression along with the plucked strings, making the tone all so creepy, depicting a great monstrous filth. Finally, the piano melody is played in a 6/8 time signature, allowing it to better pop out from the texture of the 4/4 time signature used. The piano part is meant to represent the player in the battle. Once again, the lower-voiced instruments are layered upon the melody to build intensity, while the layered strings help make the melody heard clearer. Allowing for the organ to transition smoothly back into the music in a creepy chord structure. This continues to spiral until it becomes just the melody and organ chord progressions, along with a drumset, to build momentum, and the added bass drum emphasizes the battle closing to an end. At the end, I slowly build the melody again between many instruments, drop them to the piano, and immediately swell the music back into chaos using a choir layered upon the organ chord progression. Leveling back to the melody once more in a relaxed, slow release by the harpsichord and piano.
</p>

<h2>Code</h2>
<p>
Finally, the four physics changes I added to my game were the double jump, dash, wall jump, and wall slide, all being separated in their own void functions. The first one I developed was the double jump. I used PitilT’s double jump video for guidance. Using the base jump provided by the stub game, I integrated a jumpsLeft variable and a canJump variable to the if statements conditions. JumpsLeft being a float, and canJump being a bool. In doing so, I limited my jumps using a maxJumps float and designated it only to allow one extra jump. So, every time the jump is triggered, the jumpsLeft float loses a value. Once the value is not greater than 0, the action can’t be passed anymore. To refresh this ability, an if statement below is triggered when the isGrounded bool is true. Once this is passed, the jumpsLeft is set to equal maxJumps, refunding the jumpsLeft to its original value, allowing for the action to be repeated. 
My second and hardest change was the dash ability. I used the Bendux and PitilT dash tutorial as a source. Just like the double jump ability, I utilize a dashesLeft float, a maxDashes float, and a dashed bool. In an if statement, I set my conditions to !isGrounded & dashesLeft Less Than 0 so I can only dash when I’m not colliding with terrain and limit my dash to only one use. As soon as the statement is passed, I set the canJump bool to false to negate a jump input midway through the dash. I then set the gravity scale to 0 using a reference to the player object and to its rigid body component, allowing for the dash to act in a linear path rather than a leap. A trail emitting bool is also passed for effects. Using a reference to the rigid body once again, just like the jump mechanic, I set the x value as the dash variable * the movement variable, my natural speed being 8 and the dash value increasing it by 1.5. The dashesLeft variable then loses a value by 1, preventing the dash from being activated again in the air. The dashed bool is then passed as true, triggering the next if statement (this property is duplicated for the left & right dash). The next if statement only harbors the condition dashed == true. Once this is passed, it executes the StartCoroutine method, calling the IEnumerator and my routine, StopDashing. The IEnumerator allows for the following declarations to be delayed a set amount when I use, yield return new WaitForSeconds(variable). Yield return allows for the enumerator to be returned instead and continue in the state it was in last time. Acting as a timer for the following declarations. For my use, I set my variable, dashLength, to 0.2, allowing my gravity scale to be reverted back to 3 and disable the trail rendering after 0.2 seconds of the dash input. Using an if statement, once the player isGrounded, the canJump bool is set to true again, the dashed bool is set to false, and the dashesLeft float is set to equal the maxDashes. Allowing for the jump to be activated after the finished dash and refreshing the use of the dash. 
Finally, my wall jump and slide both being sourced by Bardent wall slide tutorial. Using an if statement, I have the following conditions: isTouchingWall a bool, !isGrounded, and rb.velocity.y Greater Than 0. Using these, I pass the statement when the player model isn’t on the ground and is not in any vertical motion. IsTouchingWall, though, is activated through a physics ray cast. This ray cast needs the following parameters (origin, direction, maxDistance, layerMask). Through this, the bool acts as a trigger, and if the ray cast detects a collision within the following layerMask and distance, then the bool is set to true. Using the Gizmos, I use the static method drawline to place the position of the origin. When the following is triggered, the bool isWallSliding is set to true, and a nested if statement uses the parameters rb.velocity.y Greater Than -wallSlideSpeed. My wallSlideSpeed variable is set to 2, so when the player collides with a wall and is falling, the falling speed is faster than -2, so -2 is greater. When this is passed, the new rb.velocity changes the vertical value to -wallSlideSpeed, slowing down the fall, mimicking sliding. If the initial if statement isn’t passed, then an else statement passes the isWallSliding bool to false. The walls still count as isGrounded collisions for the first milliseconds, so the jump is refreshed every wall collision, allowing the wall sliding method to be passed right after.
The point system is the player's health system, which is displayed in a bar on the top left. I used the Brackeys Health Bar tutorial. Just like the double jump and dash, the health system uses a maxHealth int and a currentHealth int. The base of the system works off a public void function titled TakeDamage with the parameter (int damage), meaning it takes in ints’ called damage. When passed, it takes the currentHealth variable and subtracts the int passed. The healthBar script is then updated using its public void function, SetHealth. The updated currentHealth is then input into the SetHealth parameter, updating the game UI's health slider. The damage animation trigger is also set. An if statement is also there with the parameter currentHealth Less Than Or Equal To 0, and once this is passed, it calls the Die function. Public void Die includes changing the rigidbody type to static, stating “Player died!” in the console, and setting the IsDead bool to true in the animator. This plays both the animation and the RestartLevel function as an event within the animation.
</p>
</div>
</div>
</body>
</html>
